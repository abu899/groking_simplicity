# Part 1

## Ch 3

액션, 계산 데이터의 차이를 알아보기

### 액션

실행 시점이나 횟수 또는 둘다에 의존
- 부수 효과(side effect), 부수 효과가 있는 함수, 순수하지 않은 함수
- ex) 이메일 보내기, DB 읽기

액션 안에는 계산과 데이터, 또 다른 액션이 숨어 있을 수 있다. 따라서 이를 더 작은 액션과 계산, 데이터로 나눠야하는데 언제 멈춰야하는지를 아는 것이 중요하다.

### 계산

입력으로 출력을 계산
- 순수 함수, 수학 함수
- ex) 최댓값 찾기, 이메일 주소 검증

### 데이터

이벤트에 대한 사실
- 데이터를 쉽게 해석할 수 있도록 표현하는 것이 중요한 기술


### 액션이 퍼져나가는 문제

[PayoutV0](../src/main/kotlin/com/study/groking/part1/ch3/PayoutV0.kt)에서 sendPayout이 코드 전체로 퍼져나가는 걸 보자.
- sendPayout은 호출 시점과 횟수가 중요하기에 액션
- 해당 함수를 포함하고 있는 figurePayout 역시 액션이 되어버림
- 같은 문제로 affiliatePayout도 액션이 됨
- 결국 코드 안쪽의 하나의 액션으로 인해 모든 프로그램이 액션이 되어버림

액션을 가능한 작게 만들고, 액션 내에서 결정이나 계획과 관련된 부분은 계산으로 빼낼 수 있다.

---

## Ch 4

액션과 계산을 분리하지 않고 좀더 이해하기 편한 방식인 절차형 방식으로 코딩한 예를 보자([MegaMartV0](../src/main/kotlin/com/study/groking/part1/ch4/MegaMartV0.kt)).
이 방식을 테스트하기 위한 가장 간단한 방법은 다음과 같다.

1. 브라우저 설정
2. 페이지 로드
3. 장바구니에 제품 담기 버튼 클릭
4. DOM 업데이트 대기
5. DOM에서 값 획득
6. 가져온 문자열 값을 숫자로 변경
7. 예상 값과 비교

테스트해야하는 비지니스 규칙과는 관련없는 DOM 까지 확인해야하기에 테스트가 어렵다. 비지니스 규칙을 분리하고 전역변수를 없애보자

[MegaMartV1](../src/main/kotlin/com/study/groking/part1/ch4/MegaMartV1.kt)에서 아래 부분에 대한 개선을 진행
- 전역변수는 변경가능하기 떄문에 액션
- 함수에 암묵적 입력과 출력이 있으면 액션
  - 함수의 파라미터는 명시적 입력, 리턴은 명시적 출력
  - 전역변수를 읽는 것은 암묵적 입력
  - 콘솔에 찍는 것, 전역변수를 바꾸는 것은 암묵적 출력 
- 암묵적 입력은 인자로, 암묵적 출력은 리턴값으로 바꾼다

## Ch 5

### 원칙: 암묵적 입력과 출력은 적을수록 좋다

- 파라미터가 아닌 모든 입력은 암묵적 입력이고, 리턴값이 아닌 모든 출력은 암묵적 출력이다. 
- 암묵적 입출력이 존재하면 다른 컴포넌트와 강하게 결합되어 있다고 볼 수 있고, 따라서 다른 곳에서 사용하기가 어렵다.
- 암묵적 입력이 존재한다면 해당 입력이 다른 곳에서 동시에 사용되지 않게 주의해야 한다
- 암묵적 출력이 존재한다면 

### 원칙: 설계는 엉켜있는 코드를 푸는 것이다

함수를 사용하면 관심사를 자연스럽게 분리할 수 있고 언제든 쉽게 조합할 수 있다.

- 재사용하기 쉽다
- 유지보수하기 쉽다
- 테스트하기 쉽다

## Ch 6, 7

- 불변 데이터가 필요하다
  - 계산에서는 데이터에 쓰기를 할 수 없다
- copy-on-write는 데이터를 불변으로 유지할 수 있는 방법
  - 카피온라이트는 값을 변경하기 전에 `얕은 복사`를 하고 리턴
- 이를 통해 통제할 수 있는 범위에서 불변성을 구현

방어적 복사 규칙은 데이터를 변경할 수도 있는 코드와 불변성 코드 사이에 데이터를 주고 받기 위한 원칙이다.
- 데이터가 안전한 코드에서 신뢰할수 없는 코드 쪽으로 나갈때 Deep copy를 전달
- 신뢰할 수 없는 코드에서 변경될 수도 있는 데이터가 들어오는 경우 바로 Deep copy를 만들어서 안전한 코드로 전달

### Copy-on-Write vs Deep copy(Defensive Copy)

Copy-on-Write
- 통제할 수 있는 데이터를 바꿀 때 사용
- 얕은 복사(상대적으로 비용이 적게 듬)
  - 얕은 복사는 객체의 1차원 속성들만 복사
  - 얕은 복사에서는 변경되지 않은 값은 원본과 복사본이 공유

Deep Copy(Defensive Copy)
- 신뢰할 수 없는 코드와 데이터를 주고 받아야할 때 사용
- 깊은 복사(비용이 많이 듬)
  - 깊은 복사는 객체가 참조하는 모든 객체들까지 재귀적으로 복사