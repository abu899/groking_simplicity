# Part 1

## Ch 3

액션, 계산 데이터의 차이를 알아보기

### 액션

실행 시점이나 횟수 또는 둘다에 의존
- 부수 효과(side effect), 부수 효과가 있는 함수, 순수하지 않은 함수
- ex) 이메일 보내기, DB 읽기

액션 안에는 계산과 데이터, 또 다른 액션이 숨어 있을 수 있다. 따라서 이를 더 작은 액션과 계산, 데이터로 나눠야하는데 언제 멈춰야하는지를 아는 것이 중요하다.

### 계산

입력으로 출력을 계산
- 순수 함수, 수학 함수
- ex) 최댓값 찾기, 이메일 주소 검증

### 데이터

이벤트에 대한 사실
- 데이터를 쉽게 해석할 수 있도록 표현하는 것이 중요한 기술


### 액션이 퍼져나가는 문제

[PayoutV0](../src/main/kotlin/com/study/groking/part1/ch3/PayoutV0.kt)에서 sendPayout이 코드 전체로 퍼져나가는 걸 보자.
- sendPayout은 호출 시점과 횟수가 중요하기에 액션
- 해당 함수를 포함하고 있는 figurePayout 역시 액션이 되어버림
- 같은 문제로 affiliatePayout도 액션이 됨
- 결국 코드 안쪽의 하나의 액션으로 인해 모든 프로그램이 액션이 되어버림

액션을 가능한 작게 만들고, 액션 내에서 결정이나 계획과 관련된 부분은 계산으로 빼낼 수 있다.

---

## Ch 4

액션과 계산을 분리하지 않고 좀더 이해하기 편한 방식인 절차형 방식으로 코딩한 예를 보자([MegaMartV0](../src/main/kotlin/com/study/groking/part1/ch4/MegaMartV0.kt)).
이 방식을 테스트하기 위한 가장 간단한 방법은 다음과 같다.

1. 브라우저 설정
2. 페이지 로드
3. 장바구니에 제품 담기 버튼 클릭
4. DOM 업데이트 대기
5. DOM에서 값 획득
6. 가져온 문자열 값을 숫자로 변경
7. 예상 값과 비교

테스트해야하는 비지니스 규칙과는 관련없는 DOM 까지 확인해야하기에 테스트가 어렵다. 비지니스 규칙을 분리하고 전역변수를 없애보자

[MegaMartV1](../src/main/kotlin/com/study/groking/part1/ch4/MegaMartV1.kt)에서 아래 부분에 대한 개선을 진행
- 전역변수는 변경가능하기 떄문에 액션
- 함수에 암묵적 입력과 출력이 있으면 액션
  - 함수의 파라미터는 명시적 입력, 리턴은 명시적 출력
  - 전역변수를 읽는 것은 암묵적 입력
  - 콘솔에 찍는 것, 전역변수를 바꾸는 것은 암묵적 출력 
- 암묵적 입력은 인자로, 암묵적 출력은 리턴값으로 바꾼다

## Ch 5

### 원칙: 암묵적 입력과 출력은 적을수록 좋다

- 파라미터가 아닌 모든 입력은 암묵적 입력이고, 리턴값이 아닌 모든 출력은 암묵적 출력이다. 
- 암묵적 입출력이 존재하면 다른 컴포넌트와 강하게 결합되어 있다고 볼 수 있고, 따라서 다른 곳에서 사용하기가 어렵다.
- 암묵적 입력이 존재한다면 해당 입력이 다른 곳에서 동시에 사용되지 않게 주의해야 한다
- 암묵적 출력이 존재한다면 

### 원칙: 설계는 엉켜있는 코드를 푸는 것이다

함수를 사용하면 관심사를 자연스럽게 분리할 수 있고 언제든 쉽게 조합할 수 있다.

- 재사용하기 쉽다
- 유지보수하기 쉽다
- 테스트하기 쉽다

## Ch 6, 7

- 불변 데이터가 필요하다
  - 계산에서는 데이터에 쓰기를 할 수 없다
- copy-on-write는 데이터를 불변으로 유지할 수 있는 방법
  - 카피온라이트는 값을 변경하기 전에 `얕은 복사`를 하고 리턴
- 이를 통해 통제할 수 있는 범위에서 불변성을 구현

방어적 복사 규칙은 데이터를 변경할 수도 있는 코드와 불변성 코드 사이에 데이터를 주고 받기 위한 원칙이다.
- 데이터가 안전한 코드에서 신뢰할수 없는 코드 쪽으로 나갈때 Deep copy를 전달
- 신뢰할 수 없는 코드에서 변경될 수도 있는 데이터가 들어오는 경우 바로 Deep copy를 만들어서 안전한 코드로 전달

### Copy-on-Write vs Deep copy(Defensive Copy)

Copy-on-Write
- 통제할 수 있는 데이터를 바꿀 때 사용
- 얕은 복사(상대적으로 비용이 적게 듬)
  - 얕은 복사는 객체의 1차원 속성들만 복사
  - 얕은 복사에서는 변경되지 않은 값은 원본과 복사본이 공유

Deep Copy(Defensive Copy)
- 신뢰할 수 없는 코드와 데이터를 주고 받아야할 때 사용
- 깊은 복사(비용이 많이 듬)
  - 깊은 복사는 객체가 참조하는 모든 객체들까지 재귀적으로 복사

## Ch 8, 9

계층형 설계는 소프트웨어를 계층으로 구성하는 기술

### 계층형 설계 패턴

#### 패턴 1. 직접 구현

직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다.

- 직접 구현 패턴을 사용는 경우 한 함수 내에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않아 읽기가 어렵다([직접 구현V1](../src/main/kotlin/com/study/groking/part1/ch8/Pattern1_V1.kt)).
  - for loop의 추상화 단계와 makeItem과 같은 직접 만든 함수의 추상화 단계가 다름
- 개선된 코드에서는 정확히 같은 추상화 단계는 아닐 수 있지만 비슷한 추상화 단계를 사용한다([직접 구현V2](../src/main/kotlin/com/study/groking/part1/ch8/Pattern1_V2.kt)).
  - 다이어그램에서 함수를 박스로 표현하는데, 같은 박스를 가리킨다는 것은 같은 계층에 있어도 좋다는 정보이다
  - 다이어그램을 그리며 계층을 나누게 되는데, 같은 계층에 있는 함수는 같은 목적을 가져야 한다
    - 같은 동작을 수행하는게 아닌 목적
    - ex. 장바구니 비지니스 규칙, 일반적인 비지니스 규칙, 장바구니 기본 동작

#### 패턴 2. 추상화 벽(abstraction barrier)

추상화벽은 세부 구현을 감춘 함수로 이루어진 계층이며, 구현을 몰라도 함수를 사용할 수 있다.

- 쉽게 구현을 바꾸기 위해
- 코드를 읽고 쓰기쉽고 만들기 위해
- 팀 간 조율을 줄이기 위해
- 주어진 문제에 집중하기 위해
  - 구체적인 부분을 무시하고 추상화에 대한 부분에 집중

#### 패턴 3. 작은 인터페이스

작은 인터페이스 패턴은 새로운 코드를 추가할 위치에 관한 것이다. 인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있다.

- 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 고칠 게 많음
- 추상화 벽에 코드는 낮은 수준의 코드이므로 영향을 끼치는 곳이 많을 수 있음
- 추상화 벽에 코드가 많을 수록 팀 간 조율할게 많아짐

#### 패턴 4. 편리한 계층

앞서 살펴본 패턴들은 계층 구성을 만드는 이상적인 방법이지만, 이번 패턴은 좀 더 현실적이고 실용적인 측면을 고려한다.

- 현재 작업하는 코드가 편리하다면 설계는 잠시 멈춤
- 구체적인 것이 너무 많거나 코드가 지저분하다고 느끼면 다시 패턴을 적용

### 계층형 설계를 하며 그래프에서 알 수 있는 것

#### 유지보수성(Maintainability)

- 규칙: 위로 연결된 계층이 적은 함수일 수록 바꾸기 쉬움
- 즉, 계층 그래프에서 위로 연결된 화살표가 적은 함수일 수록 유지보수성이 좋음
- 핵심은 자주 바뀌는 코드는 가능한 위쪽에 위치해야 한다

#### 테스트 가능성(Testability)

- 규칙: 위로 연결된 계층이 많을수록 테스트 가치가 높다
- 즉, 계층 그래프에서 위로 연결된 화살표가 많으면 영향을 끼치는 곳이 많기에 테스트의 가치가 높다
- 핵심은 아래쪽에 있는 함수를 테스트하는 것이 가치가 높다

#### 재사용성(Reusability)

- 규칙: 아래쪽으로 연결된 계층이 많을수록 재사용이 어렵다
- 즉, 계층 그래프에서 아래로 연결된 화살표가 많으면 재사용이 어렵다
- 핵심은 낮은 수준의 단계로 함수를 빼내면 재사용성이 높아진다
